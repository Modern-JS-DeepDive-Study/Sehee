# Sehee

## 🎞 Javascript 면접 대비

### 💊 parsing은 무엇인가요?
- 텍스트 문서를 토큰으로 분해하여 트리 구조의 자료구조의 파스 트리를 생성하는 과정
- 토큰들의 집합을 구문 분석하여 AST(추상적 구문 트리)를 생성

### 💊 요소 노드를 취득하는 여러 방법을 말하고 그 차이를 설명하세요.

### 💊 Node.prototype.textContent와 Node.prototype.innerText의 차이를 설명하세요.

### 💊 바닐라JS로 복수 노드를 생성 후 추가한다고 할 때 어떻게 하는게 좋을지 설명해주세요.

### 💊 www.naver.com 을 주소창에 입력하고 엔터를 누른뒤 브라우저 화면에 내용이 출력될때까지 브라우저 내부에서 일어나는 작업 과정을 설명해주세요.
- 브라우저 렌더링은 HTML, CSS, JavaScript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정
- 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성
- 먼저 DOM을 생성하고, HTML 문서를 파싱하여 DOM 트리를 생성
- 이때, HTML 태그를 노드로 변환하고, 노드간의 계층 관계를 형성
- 두 번째로 CSSOM을 생성, 브라우저는 CSS 파일을 파싱하여 CSSOM 트리를 생성
- 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성
- 세 번째로 DOM트리와 CSSOM을 결합하여 렌더 트리를 생성
- 이때, 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성
- 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정
- 이때, 요소의 배경, 테두리, 글자 등을 그림

### 💊 http 프로토콜에 대해 설명해주세요.
- HTTP(HyperText Transfer Protocol)
- HTTP/1.1는 커넥션 당 하나의 요청과 응답만 처리
- HTTP/2.0는 커넥션 당 여러 개의 요청과 응답 가능, 여러 리소스의 동시 전송이 가능해서 HTTP/1.1에 비해 페이지 로드 속도가 약 50% 정도 빠르다고 알려져 있음

### 💊 리플로우와 리페인트에 대해 설명해주세요.
- 리플로우와 리페인트는 요소가 시각적으로 변경되었을 때, 변화를 계산하여 화면에 그려주는 작업
-  DOM이 시각적으로 변경되면 리플로우가 발생하여 렌더트리를 재생성하고, 생성된 렌더트리를 기반으로 요소를 화면에 그리는 리페인트가 발생
- `리플로우`는 요소의 너비, 높이, 위치 등이 변경되어 렌더트리를 재생성(비용이 큰 작업)
- `리페인트`는 변경된 요소를 화면에 그려주는 작업

### 💊 html script 태그의 async/defer 어트리뷰트의 차이점을 설명해주세요.

### 💊 HTMLCollection과 NodeList의 차이점에 대해 설명해주세요.
- HTMLCollection과 NodeList는 모두 유사 배열 객체이면서 이터러블, 둘 다 length 프로퍼티를 가지므로 객체를 배열처럼 접근할 수 있고 반복문을 돌 수 있음
- 그러나 유사 배열 객체이기 때문에 자바스크립트에서 제공하는 배열 객체의 메소드는 사용 불가능
- NodeList는 HTMCollection과 다르게 NodeList.prototype.forEach 메서드를 상속받아 사용 가능

### 💊 XSS란 무엇인가요? XSS의 공격 방식, 해결법 등을 간략히 설명해주세요.
- XSS(Cross Site Scripting), 웹 사이트의 관리자가 아닌 악의적인 목적을 가진 제 3자가 악성 스크립트를 삽입하여 의도하지 않은 명령을 실행시키거나 세션 등을 탈취할 수 있는 취약점
- XSS 공격을 막기 위해서는 입력 값들을 유효성 검증하고, 특수문자들을 제외하는 정규식을 통해서 제거
- 서버에서 CSP(Content-Security-Policy)정책을 설정하여, 허용된 스크립트만 실행되도록 제한
- HTTP 대신에 신뢰할 수 있는 HTTPS를 사용하여 통신 프로토콜을 암호화

### 💊 트리 자료구조에 대해 설명해주세요.
- 트리 (Tree)란 노드들이 나무 가지처럼 연결된 비선형 계층적 자료구조
- 데이터를 순차적으로 저장하지 않기 때문에 비선형 자료구조, 재귀적 자료구조
- 노드 간에 부모 자식 관계를 갖고 있는 계층형 자료구조이며 모든 자식 노드는 하나의 부모 노드만 가짐

### 💊 DOM이란 무엇인가요?
- DOM(Document Object Model), tree 형식의 자료구조
- 이 객체 모델은 문서 내의 모든 요소를 정의하고, 각각의 요소에 접근하는 방법을 제공

### 💊 자바스크립트의 객체지향 방식을 설명해주세요.

### 💊 프로토타입에 대해 아는대로 설명해주세요.

### 💊 일급 객체란 무엇인가요?
- 일급객체(First-class Object), 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체
- 무명의 리터럴로 생성 가능, 런타임에 생성 가능
- 변수나 자료구조(객체, 배열 등)에 저장 가능
- 함수의 매개변수에 전달 가능
- 함수의 반환값으로 사용 가능

### 💊 호이스팅에 대해 설명해주세요.

- 호이스팅은 변수와 함수 선언이 스코프(scope)의 최상단으로 올려져 실행되는 것을 의미
- 이로 인해 선언 전에 사용하는 경우 오류가 발생할 가능성 존재

### 💊 클로저(closure)에 대해 설명해주세요.

- 함수가 선언될 때 자동으로 생성되는 렉시컬 환경에 대한 설명
- 이러한 렉시컬 환경은 스코프 체인(scope chain)을 형성하게 되는데, 스코프 체인은 함수가 선언될 때의 모든 변수와 함수를 포함하는 렉시컬 스코프(lexical scope)를 형성
- 외부 함수가 실행 되고 반환된 후에도 외부 함수의 범위 내의 함수에 체이닝을 할 수 있는 함수
- 정보를 은닉하기 위해서 주로 사용

### 💊 www.naver.com 을 주소창에 입력하고 엔터를 누른뒤 브라우저 화면에 내용이 출력될때까지 브라우저 내부에서 일어나는 작업 과정을 설명해주세요.
- `브라우저 렌더링`은 HTML, CSS, JavaScript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정
- 브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성
1. 먼저 DOM을 생성하고, HTML 문서를 파싱하여 DOM 트리를 생성, HTML 태그를 노드로 변환하고, 노드간의 계층 관계를 형성
2. 두 번째로 CSSOM을 생성, 브라우저는 CSS 파일을 파싱하여 CSSOM 트리를 생성, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성
3. 세 번째로 DOM트리와 CSSOM을 결합하여 렌더 트리를 생성, 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성
4. 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정을 거치고 이때 요소의 배경, 테두리, 글자 등을 그림

### 💊 호이스팅(Hoisting)에 대해서 설명해주세요
- 호이스팅은 `변수와 함수 선언이 스코프(scope)의 최상단으로 올려져 실행되는 것`을 의미
- 이로 인해 **선언 전에 사용하는 경우 오류가 발생할 가능성** 존재
- `var`로 선언한 변수의 경우 호이스팅 시 `undefined`로 변수를 초기화하기 때문에 변수를 선언하기 전에 참조 가능
-`let`과 `const`로 선언한 변수의 경우 호이스팅 시 변수를 초기화하지 않음

### 💊 Sync와 Async의 차이점을 설명해주세요
- 동기와 비동기는 `특정 작업을 수행할 때 해당 작업의 완료 여부를 신경 쓰는지`에 따라 구분
- 동기 작업은 요청한 작업에 대해 순서가 지켜지고, 비동기 작업은 순서가 지켜지지 않을 수 있음
- `동기`는 요청을 보낸 후 기다렸다가 해당 응답을 받아야 다음 동작을 수행, `호출된 함수의 실행 결과, 종료를 호출한 함수가 관심을 가지고 있는 경우`
- `비동기`는 요청을 보낸 후 응답을 기다리지 않고 다음 동작을 수행, `호출된 함수의 실행 결과, 종료를 호출한 함수가 관심을 가지지 않은 경우`

### 💊 Blocking과 Non-Blocking의 차이를 설명해주세요.
- 블로킹과 논블로킹은 `다른 주체가 작업할 때 자신의 제어권이 있는지 없는지로 구분`
- `Blocking`은 자신의 작업을 진행하다가 다른 주체의 작업이 시작되면 다른 작업이 끝날 때까지 기다렸다가 자신의 작업을 시작하는 것을 의미, `호출된 함수가 자신의 할 일을 모두 마칠때까지 제어권을 가지고 있음`
- `Non-Blocking`은 다른 주체의 작업에 관련없이 자신의 작업을 하는 것을 의미, `호출된 함수가 자신의 할 일을 모두 마치지 않았더라도 제어권 넘겨줌`

**✅ 비동기 `출력 순서`와 관련된 개념이고 논블로킹이 `병렬 실행`과 관련된 개념**

### 💊 콜백함수에 대해 설명해주세요
- `콜백 함수`는 전달인자로 다른 함수에 전달되는 함수
- 매개변수로 함수 객체를 전달해서 호출 함수 내에서 매개변수 함수를 실행하는 것
- 익명 화살표 함수 사용(코드의 간결성)

### 💊 콜백지옥의 의미와 콜백지옥을 해결하는 방법을 설명해주세요.
- `콜백지옥`이란 콜백 함수를 전달하는 과정에서 또 다시 콜백 함수 안에 함수 호출이 반복되어 여러 겹 중첩해서 가독성이 나빠지고, 유지보수가 어려워지는 문제

1. `콜백 함수를 외부로 분리`, 비동기 작업의 결과를 처리하는 콜백 함수를 따로 정의하고 해당 함수를 콜백으로 사용
2. `프로미스(Promise)사용`,  콜백 함수 대신 `then(), catch()`메서드를 활용하여 비동기 작업 처리
3. `async/await 문법 사용`, `async` 키워드로 비동기 함수를 선언하고, `await` 키워드를 사용하여 비동기 작업의 결과를 기다림

### 💊 Promise를 이용한 비동기 통신과 Async, Await를 사용한 비동기 통신의 차이를 설명해주세요.
- `async/await 문법`에서는 `try...catch문으로 에러 처리가 가능`하지만 Promise문은 불가능! 프로미스를 반환하는 비동기 함수는 명시적으로 호출이 가능해서, 호출자가 명확하기 때문에 try catch 문으로 에러를 처리할 수 있고, `최종적으로 catch 문에서 에러를 출력하는 Promise`와 달리 쉽게 문제가 발생한 부분을 찾을 수 있다는 장점도 존재
- `async/await 문법은 코드 가독성 좋고 동기적인 순서로 코드를 쉽게 파악 가능`하지만 Promise는 과한 프로미스 체이닝으로 가독성이 떨어질 가능성 존재

### 💊 map과 forEach의 차이를 설명해주세요.
- `공통점`은 `배열을 이용!`, 배열의 값을 조작해서 원하는 결과값을 도출
- `forEach()`는 배열 요소마다 한 번씩 주어진 함수를 실행, `forEacn()문 밖으로 리턴값을 받지 못함`
- `map()`은 배열 내의 모든 요소 각각에 대하여 주어진 콜백 함수를 호출한 결과를 모아 `새로운 배열을 반환`, `map()은 리턴값 출력 가능
`
### 💊 var, let, const의 차이를 설명해주세요.

#### ✅ var
- 중복 선언 가능, 함수레벨 스코프
#### ✅ let
- 중복 선언 불가능, 재할당 가능, 블록레벨 스코프
#### ✅ const
- 중복 선언 불가능, 재할당 불가능, 블록레벨 스코프
- 변수를 선언하기 전에 참조할 수 없으며, 변수를 선언할 시 반드시 할당 해야 함

### 💊 메서드 체이닝에 대해 설명해주세요.
- `Method Chaining`이란 메서드가 객체를 반환하게 되면 메서드의 반환 값인 객체를 통해 또 다른 함수를 호출하는 것
- 코드가 간략해지는 장점이 있지만 에러 발생 시 어느 부분에서 에러가 발생했는지 알기 어려움

### 💊 일반 함수와 화살표 함수의 차이에 대해 설명해주세요.

#### ✅ this
- 일반함수: 함수의 호출 방식에 따라 `this에 바인딩할 객체가 동적으로 결정`
- 화살표함수: this는 언제나 `상위 스코프의 this(Lexical this)`를 가리키며, `this에 바인딩할 객체가 정적으로 결정`

#### ✅ Arguments
- 일반함수: 함수 실행 시 암묵적으로 arguments 변수가 전달되어 사용 가능
- 화살표함수: arguments 객체를 생성하지 않음

#### ✅ 생성자 함수 사용
- 일반함수: `new` 키워드를 통해 생성자 함수로 사용 가능
- 화살표함수: `prototype property`가 없기 때문에 `new` 키워드를 사용하여 생성자 함수로 사용 불가능

### 💊 this의 의미를 설명해주세요.
#### ✅ this: 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
- `함수의 호출 방식`에 따라 `특정 객체`를 바인딩

1. 생성자 함수 내부: 생성자 함수가 생성할 인스턴스와 바인딩
2. Call, Apply, Bind 메서드: 함수의 첫 번째 인수로 전달하는 객체에 바인딩
3. Object.method 형태과 같이 객체 내에서 호출: 해당 객체와 바인딩
4. 위의 3가지 경우 제외한 일반 함수: 전역 객체와 바인딩
5. 화살표 함수 내에서: 상위 스코프의 this와 바인딩

### 💊 함수 선언식과 함수 표현식의 차이를 설명해주세요.

#### ✅ 함수 선언식
- 코드가 실행되기 전에 로드, 호이스팅 가능
```
alert(foo()); 
// Alerts 5. 
// 선언 전에 호출되도 정상 동작

function foo() { return 5; }
```
#### ✅ 함수 표현식
- 인터프리터가 해당 코드 줄에 도달할 때만 로드
- 함수 이름이 필요 없기 때문에 가독성이 높음
- 호이스팅 불가능, 정의된 범위에서 로컬 변수의 복사본 유지 가능
```
alert(foo()); // 에러 발생! foo 함수는 아직 로드안됨
var foo = function() { return 5; }
```

### 💊 이벤트 전파와 이벤트 위임에 대해 설명해주세요.
#### ✅ 이벤트 전파
- DOM 트리 상에 존재하는 DOM 요소 노트에서 발생한 이벤트는 이벤트를 통해 전파
1. 캡처링 단계: 이벤트가 상위 요소에서 하위 요소 방향으로 전파
2. 타킷 단계: 이벤트가 이벤트 타깃에 도달
3. 버블링 단계: 이벤트가 하위 요소에서 상위 요소 방향으로 전파

#### ✅ 이벤트 위임
- 여러 개의 하위 DOM 요소에 각각 이벤트 핸들러를 등록하는 대신 하나의 상위 DOM 요소에 이벤트 핸들러를 등록하는 방법
- 이벤트는 상위 DOM에서도 캐치 가능하므로 여러 개의 하위 DOM 요소에 이벤트 핸들러를 등록할 필요가 없음

### 💊 이벤트 버블링과 이벤트 캡처링에 대해 설명해주세요.
#### ✅ 이벤트 버블링
- 이벤트가 발생한 요소부터 점점 부모 요소를 거슬러 올라가서 window까지 이벤트를 전파
- 거의 모든 이벤트는 버블링(focus, load, unload, mouseenter, mouseleave 등 제외)

#### ✅ 이벤트 캡처링
- window부터 이벤트가 발생한 요소까지 이벤트를 전파
- 캡처링 단계에서 이벤트를 잡아내려면 `addEventListener`의 `capture` 옵션을 `true`로 설정

### 💊 스코프와 스코프 체인에 대해 설명해주세요.
#### ✅ 스코프
- 해당 변수가 선언되어있는 공간이나 환경
- 즉 각각의 변수, 매개변수, 함수 등이 유효한 영역
- 자바스크립트는 함수 스코프를 사용하므로, 함수 내에 정의된 변수는 해당 함수 내에서만 유효

1.전역 스코프: 코드 어디에서나 접근 가능
2.함수 스코프: 함수 내에서만 유효한 범위를 가짐
3.블록 스코프: 블록단위 `{}` 내에서만 유효한 범위를 가짐

#### ✅ 스코프 체인
- 지역 스코프 내에 원하는 식별자가 선언되어있지 않을 경우 `상위 스코프로 올라가서` 유요한 해당 값을 차례로 검색
- 스코프의 상하관계

### 💊 렉시컬 스코프에 대해 설명해주세요.
- 정적 스코프(Static Scope)
- 식별자 유효 범위가 함수를 호출할 때 결정되는 것이 아닌, 선언할 때 결정되는 것(어디서 정의했는지에 따라 상위 스코프 결정)

### 💊 클로저에 대해 설명해주세요.
- 함수가 선언될 때 자동으로 생성되는 렉시컬 환경에 대한 설명
- 이러한 렉시컬 환경은 스코프 체인(scope chain)을 형성하게 되는데, 스코프 체인은 함수가 선언될 때의 모든 변수와 함수를 포함하는 렉시컬 스코프(lexical scope)를 형성
- 외부 함수가 실행 되고 반환된 후에도 외부 함수의 범위 내의 함수에 체이닝을 할 수 있는 함수
- `정보를 은닉`하기 위해서 주로 사용

### 💊 실행 컨텍스트에 대해 설명해주세요.
- `실행할 코드에 제공할 환경 정보들을 모아놓은 객체`
- 동일한 환경에 있는 코드들을 실행할 때 필요한 환경 정보들을 모아 객체를 구성하고, 이를 콜 스택에 쌓아올렸다가 가장 위에 쌓여있는 컨텍스트와 관련 있는 코드들을 실행하는 식으로 `전체 코드의 환경과 순서를 보장` 
1. 전역 컨텍스트 생성 후 함수가 호출될 때마다 함수 컨텍스트가 생성되고, 컨텍스트 생성 시 변수 객체, 스코프 체인, this 생성
2. 함수 호출이 종료되면 해당 함수 컨텍스트가 사라지고, 페이지가 종료되면 전역 컨텍스트도 사라짐

### 💊 프로토타입과 프로토타입 체인에 대해 설명해주세요.
#### ✅ 프로토타입(Prototype)
- 자바스크립트: 프로토타입 기반의 객체지향 프로그래밍 언어, `프로토타입을 기반으로 상속 구현`
-
#### ✅ 프로토타입 체인

### 💊 깊은 복사와 얕은 복사의 차이점을 설명해주세요.

#### ✅ 얕은 복사(Shallow Copy)
- `객체의 참조값(주소)`를 복사
- 데이터 자체를 복사하지 않고 해당 데이터의 참조값을 전달하여 `하나의 데이터를 공유`
- 복사된 값을 수정하는 경우 원시값에 영향을 미치므로 주의 필요
#### ✅ 깊은 복사(Deep Copy)
- 새로운 메모리 공간을 확보하여`객체의 값 자체`를 복사
- 원본과의 참조가 완전히 끊어진 객체

### 💊 구조 분해 할당(destructing)에 대해 설명해주세요.

### 💊 spread 문법과 rest 문법의 차이에 대해 설명해주세요.

### 💊 ES6에서 생긴 큰 변화들에 대해 설명해주세요.

### 💊 Ajax에 대해 설명해주세요.

### 💊 import와 require의 차이점에 대해 설명해주세요.

### 💊 npm에 대해 설명해주세요.
- `Node Package Manager`의 약어, 프로젝트에 사용되는 의존성들을 관리할 수 있는 도구
- Node.js에서 사용하는 패키지 다운로드 할 수 있는 프로그램

### 💊 package.json과 package-lock.json의 역할에 대해 설명해주세요.

#### ✅ package.json
- Node.js 프로젝트에서 사용되는 파일
- 프로젝트의 이름, 버전, 설명, 작성자, 라이센스, 프로젝트 실행에 필요한 서드파티 패키지인 의존성 목록 포함
- 터미널에서 `npm install` 입력 시 `package.json`에 나열된 의존성이 자동으로 설치되므로 프로젝트 의존성을 쉽게 관리 가능하며 `필요한 패키지의 동일한 버전을 사용하는 모든 사용자 보장 가능`

#### ✅ package-lock.json
- `의존성 트리에 대한 정보`, package-lock.json 파일이 작성된 시점의 의존성 트리가 재생성 가능
- package.json에 선언된 패키지가 설치될 때 정확한 `version`과 `dependency`가 설치되도록 해주는 파일

### 💊 typescript를 쓰는 이유에 대해 설명해주세요.

### 💊 null, undefined, undeclared, NaN에 대해 설명해주세요.

### 💊 자바스크립트 데이터 타입에 대해 설명해주세요.

### 💊 mutable과 immutable에 대해 설명해주세요.

### 💊 throttle과 debounce에 대해 설명해주세요.

### 💊 iterable, iterator, generator에 대해 설명해주세요.

### 💊 자바스크립트 동작 원리에 대해 설명해주세요.