## 🗂️ 17장. 생성자 함수에 의한 객체 생성

### 목차
- [17.1 Object 생성자 함수](#17.1)
- [17.2 생성자 함수](#17.2)

<br/>

**💡 생성자 함수(constructor)**: `new 연산자`와 `함께` 호출하여 객체(인스턴스)를 생성하는 함수

**💡 인스턴스(instance)** : 생성자 함수에 의해 생성된 객체

**💡 바인딩(name binding)**: 식별자와 값을 연결하는 과정

Object, String, Number, Boolean, Function, Array, Date, RegExp., Promise 등의 빌트인 생성자 함수 제공

### 17.1 Object 생성자 함수<a name="17.1"></a>
---

- `new` 연산자와 함께 `Object 생성자 함수 호출` -> 빈 객체를 생성하여 반환
- 빈 객체 생성 이후 프로퍼티 또는 메서드 추가하여 객체 완성 가능

### 17.2 생성자 함수<a name="17.2"></a>
---

#### ✅ 객체 리터럴에 의한 객체 생성 방식의 문제점
- 직관적이고 간편하나, 단 하나의 객체만 생성함
- 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우 매번 같은 프로퍼티를 기술해야 함 -> **비효율적**

#### ✅ 생성자 함수에 의한 객체 생성 방식의 장점
- 객체(인스턴스)를 생성하기 위한 템플릿(클래스)처럼 생성자 함수를 사용
- 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성 가능

#### ✅ 생성자 함수의 인스턴스 생성 과정
- 역할: **인스턴스 생성**, 생성된 인스턴스 초기화(프로퍼티 추가 및 초기값 할당)
- 자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성 및 반환

1. 인스턴스 생성과 this 바인딩
- 암묵적으로 생성된 빈 객체(인스턴스)는 this에 바인딩
- 생성자 함수 내부의 this === 생성자 함수가 생성할 인스턴스를 가리킴

2. 인스턴스 초기화
- **(개발자가 기술)** this에 바인딩되어 있는 인스턴스에 프로퍼티나 메서드를 추가
- 인수로 전달받은 초기값을 프로퍼티에 할당하여 초기화 하거나 고정값을 할당

3. 인스턴스 반환
- 내부에서 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this를 암묵적으로 반환
- 다른 객체를 명시적으로 반환하면 this가 아니라 명시한 객체가 반환되고, 명시적으로 원시 값을 반환하면 원시 값 반환이 무시되고 암묵적으로 this가 반환
- **내부에서 return 문을 반드시 생략**
```js
function Circle(radius) {
  // 1. 암묵적으로 빈 객체 생성, this에 바인딩

  // 2. this에 바인딩되어 있는 인스턴스를 초기화
  this.radius = radius;
  this.getDiameter = function () {
      return 2 * this.radius;
  };

  // 3. 암묵적으로 this를 반환
}

// 인스턴스 생성
const circle = new Circle(1);
console.log(circle); // Circle {radius: 1, getDiameter: f}
```

#### ✅내부 메서드 [[Call]]과 [[Construct]]
- 함수는 **객체**, 일반 객체와 동일하게 동작 가능 -> 내부 슬롯 & 메서드 모두 소유
- 함수 객체는 호출 가능(일반 객체 호출 X)
  - 일반 객체가 가지고 있는 내부 슬롯, 내부 메서드
  - 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등의 내부 슬롯
  - 함수 객체만을 위한 [[Call]], [[Construct]] 같은 내부 메서드
- callable : `일반 함수로서 호출`되면 `[[Call]]이 호출`
- constructor: `new 연산자와 함께 생성자 함수로서 호출`되면 `[[Construct]]가 호출` 
- 모든 함수 객체는 [[Call]]을 갖고있지만, 모든 함수 객체가 [[Construct]]를 갖는 것은 아님!

#### ✅constructor와 non-constructor의 구분
- 함수 객체를 생성할 때 **함수 정의 방식에 따라** constructor, non-constructor 구분
- `constructor` : 함수 선언문, 함수 표현식, 클래스
- `non-constructor` : 메서드(ES6 메서드의 축약 표현), 화살표 함수
- [주의] 생성자 함수로서 호출될 것을 기대하고 정의하지 않은 일반함수에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작 가능

#### ✅new 연산자
- 일반 함수와 생성자 함수의 특별한 형식적 차이는 X, `생성자 함수는 파스칼 케이스로 명명`
- `new 연산자`와 함께 호출하면 생성자 함수로 동작
- [[Call]]이 아닌 [[Construct]]가 호출되며 당연히 non-constructor가 아닌 constructor이어야 함
- 반대로 new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출 -> [[Construct]]가 아닌 [[Call]]이 호출

#### ✅new.target(ES6에서 지원)
- **생성자 함수가 new 연산자 없이 호출되는 것을 방지**
- this와 유사하게 constructor인 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용, `메타 프로퍼티`
- new 연산자와 함께 생성자 함수로서 호출되면 ? new.target은 함수 자신
- 일반 함수로서 호출되면 ? new.target은 undefined
